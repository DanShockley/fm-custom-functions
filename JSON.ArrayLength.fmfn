/**
 * VERSION:			1.0.0
 * Function Name: 	JSON.ArrayLength()
 * Name Dependency: yes (i.e. recursion, must update the code if renaming the function)
 * Purpose: 		Determine the length of a JSON array
 *
 * @param {string}	JSON_Array = JSON array object
 *
 * @returnSuccess {integer} length of the array
 * @returnError {JSON Array} error[n].code = error code
 * @returnError {JSON Array} error[n].description = description of error
 * @returnError {JSON Array} error[n].notes = additional notes about the error
 * 
 * @author Allen Ulbricht, https://github.com/aulbricht
 * @website http://northcoastsoftware.com
 *
 */

 Let ([
	~json = JSON_Array;
	~jsonVal = JSONFormatElements ( ~json );
	~error = Case (
				Left ( ~jsonVal; 1 ) = "?"; JSONSetElement ("{}"; 
					[ "error[0].code"; -2; JSONNumber ]; 
					[ "error[0].description"; "JSON invalid"; JSONString ]
					);
				Left ( ~jsonVal; 1 ) â‰  "["; JSONSetElement ("{}"; 
					[ "error[0].code"; -2; JSONNumber ]; 
					[ "error[0].description"; "JSON invalid: expecting a JSON array"; JSONString ];
					[ "error[0].notes"; "Each JSON to be concatentated must be an array"; JSONString ]
					)
				);
	~result = JSONDeleteElement ( ~json; "[0]" ); // remove the current array value
	~next = If ( not IsEmpty ( JSONGetElement ( ~result; "[0]" )); // check to see if any values remain in the array
				JSON.ArrayLength ( ~result ); // if any values remain, recurse
				0 // if no values remain, return starting count of 0
				);
~=""];

Case ( 
	not IsEmpty ( ~error ); ~error; // if this iteration had an error, return it instead of a number
	Length ( Filter ( ~next; "0123456789" )) = Length ( ~next ); ~next + 1; // if only a positive integer was returned from the next recursion, add the value; otherwise just return the non-numeric value
	~next
)

)