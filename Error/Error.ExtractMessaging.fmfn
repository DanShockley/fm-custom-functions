/********
 * 
 * Extract the custom error message(s) from the json object
 * 
 * @param {object} errorObject - the error JSON object or array
 * 
 * @return {text} description of the error, or value list of descriptions if multiple
 * 
 * @module Error
 * 
 * @version 1.0.0
 * @author Allen Ulbricht, https://github.com/aulbricht
 * 
 *******/


Let ([

	~json = errorObject ;

	~formattedData = JSONFormatElements ( ~json );

	// If errorObject is an ARRAY of errors
	~isArray = Left ( ~formattedData ; 1 ) = "[" ;
	~numErrors = If ( ~isArray ; ValueCount ( JSONListKeys ( ~json ; "." ) ); "" );
	~lastCell = ~numErrors - 1 ;
	~cell = "[" & ~lastCell & "]" ;

	// Get error message (if array: extract the last error message in the array)
	~errorMessage  =  Let ([ 
				~errorCode = JSONGetElement ( ~json ; If ( ~isArray ; ~cell & "." ) & "errorCode" );
				~descriptor = JSONGetElement ( ~json ; If ( ~isArray ; ~cell & "." ) & "descriptor" );
				~message = JSONGetElement ( ~json ; If ( ~isArray ; ~cell & "." ) & "message" )
				];
					If ( not IsEmpty ( ~descriptor ) ; 
						~descriptor ; 
						Error.GetDescriptor ( ~errorCode ) 
						)
					& If ( not IsEmpty ( ~message ) ; ": " & ~message )
				);

	// If there are multiple array cells, remove the last one to prepare for recursive call
	~json_updated = If ( ~numErrors > 1 ; JSONDeleteElement ( ~json ; ~cell ) );

	// Compile list of messages (if multiple), and make next recursive call if necessary
	~LIST_messages = List ( 
				If ( ~numErrors > 1 ; 

					// RECURSIVE CALL //////////////////////
					Error.GetMessage ( ~json_updated ) ;
					///////////////////////////////////////////

					""
					);
				~errorMessage
				);

~=""];

Case (

	// invalid JSON
	Left ( ~formattedData ; 1 ) = "?" ; JSON.Validate._errorCreate( "" ; List ( "Error object to validate is invalid JSON" ; ~json ) );

	~LIST_messages 

)

)
