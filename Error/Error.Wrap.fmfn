/********
 * 
 * Wrap the error in a JSON Object
 * 
 * @param {number} errorCode - the FileMaker Error Code.
 * @param {string} descriptor - describe where the error is happening
 * @param {text or object} [data] - optional extra data to include in the error object
 * @param {object} [errorArray] - optional include an existing array or object to create or add to an error array
 * 
 * @return {array} an array of errors. Note: if there is only one error, it will be an object
 * 
 * @module Error
 * 
 * @version 1.2.0
 * @author Allen Ulbricht, https://github.com/aulbricht
 * @credit Forked from code by original author Todd Geist
 * 
 *******/


Let ([

	~descriptor = descriptor ;
	~data = data ;
	~array = errorArray ; 
	~nextArrayCell = If ( not IsEmpty ( ~array ) ; 
						ValueCount ( JSONListKeys ( ~array ; "." ) );
						0 
						);

	~error = errorCode ;
	~error = If( IsEmpty ( ~error ) ; 0 ; GetAsNumber ( ~error ) );

	~base = JSONSetElement ( "{}" ; "errorCode" ; ~error ; JSONNumber );
	~basePlusMessage = If ( ~error â‰  0 ; 
				JSONSetElement ( ~base ; "errorMessage"; Error._getDescriptor ( ~error ) ; JSONString ) ; 
				~base 
				);
	
	~data = If ( IsEmpty ( ~data );
				JSONSetElement ( "{}" ;
					[ "accountName" ; Get ( AccountName ) ; JSONString ];
					[ "accountPrivilegeSetName" ; Get ( AccountPrivilegeSetName ) ; JSONString ];
					[ "filename" ; Get ( FileName ) ; JSONString ];
					[ "scriptParameter" ; Get ( ScriptParameter ) ; JSONString ];
					[ "scriptResult" ; Get ( ScriptResult ) ; JSONString ];
					[ "lastODBCError" ; Get ( LastExternalErrorDetail ) ; JSONString ];
					[ "layoutName" ; Get ( LayoutName ) ; JSONString ];
					[ "layoutTableName" ; Get ( LayoutTableName ) ; JSONString ];
					[ "recordOpenCount" ; Get ( RecordOpenCount ) ; JSONNumber ];
					[ "recordModificationCount" ; Get ( RecordModificationCount ) ; JSONNumber ];
					[ "activeFieldName" ; Get ( ActiveFieldName ) ; JSONString ];
					[ "activeFieldTableName" ; Get ( ActiveFieldTableName ) ; JSONString ];
					[ "activeLayoutObjectName" ; Get ( ActiveLayoutObjectName ) ; JSONString ]
					)
				);
	~dataType = Let ( ~leftChar = Left ( JSONFormatElements ( ~data )  ; 1 ); 
							Case ( 
								~leftChar = "{" or ~leftChar = "[" ; JSONObject ; 
								JSONString 
								) 
							);
	
	~currentError = 
		Case (
			not ~error ; ~base ;
			JSONSetElement( ~basePlusMessage ; 
				[ "scriptName" ; Get ( ScriptName ) ; JSONString ];
				[ "type" ; "FM" ; JSONString ] ;
				[ "descriptor" ; ~descriptor ; JSONString] ;
				[ "data" ; ~data ; ~dataType ] 
			 )

	);

~=""];

Case (
	
	// If the error code is 0, do not add it to the errors array; rather, return the original error object
	~error = 0 or IsEmpty ( ~error ) ; ~array ;

	// If no additional errors were provided, just return the new error object
	IsEmpty ( ~array ) ; ~currentError ;
	
	// If the provided error object is an array already, append the current error object
	Left ( ~array ; 1 ) = "[" ; 
		JSONFormatElements (
			JSONSetElement( ~array ; ~nextArrayCell ; ~currentError ; JSONObject )
			);

	// If the provided error object is a single error object, create an array out of the two objects
	Left ( ~array ; 1 ) = "{" ; 
		JSONFormatElements (
			JSONSetElement ( "[]" ; 
				[ "[0]" ; ~array ; JSONObject ];
				[ "[1]" ; ~currentError ; JSONObject ]
				)
			)

)

)