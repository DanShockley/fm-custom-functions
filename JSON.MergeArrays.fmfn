/**
 * VERSION:			1.0.0
 * Function Name: 	JSON.MergeArrays()
 * Name Dependency: yes (i.e. recursion, must update the code if renaming the function)
 * Purpose: 		Merge two JSON arrays
 *
 * @param {JSON Array} array1 = JSON array
 * @param {JSON Array} array2 = JSON array
 *
 * @returnSuccess {JSON} merged JSON object
 * @returnError {JSON Array} error[n].code = error code
 * @returnError {JSON Array} error[n].description = description of error
 * @returnError {JSON Array} error[n].notes = additional notes about the error
 * 
 * @author Allen Ulbricht, https://github.com/aulbricht
 * @website http://northcoastsoftware.com
 *
 */

 Let ([

	// Abstract the input variables
	~array1 = array1 ;
	~array2 = array2 ;

	// Validate the array variables are valid JSON
	~jsonValidate1 = JSONFormatElements ( ~array1 );
	~jsonValidate2 = JSONFormatElements ( ~array2 );

	// Validate the JSON variables are arrays (rather than standard JSON objects)
	~isArray1 = Left ( ~array1 ; 1 ) = "[" ;
	~isArray2 = Left ( ~array2 ; 1 ) = "[" ;

	// Handle any validation errors
	~error = Case (

			Left ( ~jsonValidate1 ; 1 ) = "?" or Left ( ~jsonValidate2 ; 1 ) = "?"; JSONSetElement ("{}"; 
				[ "error[0].code"; -2; JSONNumber ]; 
				[ "error[0].description"; "JSON invalid"; JSONString ]
				);

			not ( ~isArray1 and ~isArray2 ) ; JSONSetElement ("{}"; 
				[ "error[0].code"; -2; JSONNumber ]; 
				[ "error[0].description"; "JSON is not a valid array"; JSONString ]
				);

			);

	
	// Determine the next array cell number to merge data into
	// Note: since array cells start at zero (not one), the next array cell will be equal to the count of current cells, so we don't need a "+1"
	~nextArrayCell = ValueCount ( JSONListKeys ( ~array1 ; "." ) );


	// Get the next array2 cell data to be merged (the first cell)
	~value = JSONGetElement ( ~array2 ; "[0]" );

	// Determine the data type which to set the data to the combined JSON object
	~type = Case ( 
			Left ( JSONFormatElements ( ~value ) ; 1 ) ≠ "?" and Left ( ~value ; 1 ) = "{" ; JSONObject ;
			Left ( JSONFormatElements ( ~value ) ; 1 ) ≠ "?" and Left ( ~value ; 1 ) = "[" ; JSONArray ;
			GetAsText ( GetAsTimestamp ( ~value ) ) = ~value ; JSONString;
			GetAsTime ( ~value ) = ~value ; JSONNumber; // note: using GetAsTime on a number will equal the number, but not if the same value is set as text
			GetAsText ( ~value ) = ~value ; JSONString;
			);

	// Merge the next data bit from array2 into array1
	~jsonMerged = JSONSetElement ( ~array1 ; "[" & ~nextArrayCell & "]" ; ~value ; ~type );

	// Remove the array2 cell we just merged (the first cell)
	~jsonRemaining = JSONDeleteElement ( ~array2 ; "[0]" );

	// Determine how many more values remain to be merged
	~valuesRemaining = ValueCount ( JSONListKeys ( ~jsonRemaining ; "." ) ) ;
	
~=""];

Case ( 

	// If this iteration had an error, return it instead of a number
	not IsEmpty ( ~error ); ~error; 

	// If there are more keys in array2 to merge, recurse to process the next cell
	~valuesRemaining > 0 ; JSON.MergeArrays ( ~jsonMerged ; ~jsonRemaining ) ; 

	// If there are no additional keys left to merge, return the final merged object
	~jsonMerged 

)

)