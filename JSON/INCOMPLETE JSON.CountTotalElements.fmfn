DEBUG COPY ON TOP

/**
 * 
 * Count total number of nested elements
 *
 * @param {object} json - JSON object
 * @param {text} [startingElementKey] - OPTIONAL: start at the given element, i.e. only return nested count within this element
 *
 * @returnSuccess {number} count of elements
 *
 * @module JSON
 * 
 * @version 1.0.0
 * @author Allen Ulbricht, https://github.com/aulbricht
 *
 */

While ( 

	//// initial variables ////
	[ 

		~json = $$runResults ;
		~startingKey = "." ;
		~startingKey = If ( not IsEmpty ( ~startingKey ) ;  ~startingKey ; "." );

		// check for existing and valid original object
		~json = 
			If ( 
				IsEmpty ( ~json ) 
					or Left ( JSONFormatElements ( ~json ) ; 1 ) = "?" ;
				"{}" ;
				~json
				);

		~key_prev = ~startingKey ;
		~key_prev_level = ~startingKey ;

		~key_rootFinal = 
			Let ( ~list = JSONListKeys ( ~json ; ~startingKey );
				GetValue ( ~list ; ValueCount ( ~list ) ) 
				);

		// set the maximum number of iterations as a safety catch against inifite loops
		~maxItems = 1000 ;
		~i = 1 ;
		
		~=""] ; 

	//// "while this is true" loop condition ///////
	~json ≠ "{}" and not IsEmpty ( ~json ) and ~i ≤ 3 ;//~maxItems ; 

	//// logic ////////////////
	[ 


		////////////////////////////////////////////////////////////////
		// get the next deepest key, else get the next root key
		// note: the current key is always the deepest, next child key in the object

		~key = 
			While ( 

				//// initial variables ////
				[ 
		
					~json_local = ~json ;
					~key_compiled = "" ;
					~element = "." ; // note: this needs a starting value so the loop doesn't insta-exit
					~maxNestedLevels = 8 ;
					~n = 1 ;
		
					~=""] ; 

				//// "while this is true" loop condition ///////
				not IsEmpty ( ~element ) and ~n ≤ ~maxNestedLevels ; 

				//// logic ////////////////
				[ 

					~isArray = 
						Let ( ~v = ~json_local ; 
							Left ( ~v ; 1 ) = "["
							);
					~key = GetValue ( JSONListKeys ( ~json ; "." ) ; 1 );
					~json_local = JSONGetElement ( ~json_local ; ~key );

					~key_compiled = ~key_compiled & If ( Right ( ~key_compiled ; 1 ) ≠ "." and ~element ≠ "." ; "." ) & ~key ;
					~element =
						Let ( ~list_nextNestedElements = JSONListKeys ( ~json ; ~key_compiled );
							GetValue ( ~list_nextNestedElements ; 1 )
							);
					~element = If ( ~isArray ; "[" & ~element & "]" ; ~element );


$sg = If ( ~n = 1 ;

List (
"~json_local = " & ~json_local ; 
"-";
"~isArray = " & ~isArray ;
"~element = " & ~element ;
"~key_compiled = " & ~key_compiled ;
"~n = " & ~n - 1 ;
);

$sg);

					~n = ~n + 1 ;

					~=""] ; 

				//// result ///////////////

				~key_compiled 

				);

		////////////////////////////////////////////////////////////////



		// get value for the current key
//		~json = JSONDeleteElement ( ~json ; ~key );

		// if there are nested elements, manage next behavior appropriately
/*
		~skipThisKey = 
			Let ( ~nestedKeys = JSONGetElement ( ~json ; ~key );

				// if there are no nested keys
				ValueCount ( ~nestedKeys ) = 0

				// if there is only a blank JSON object
				or ~nestedKeys = "{}" 

				);
*/

		// track the number iterations
		~i = ~i + 1 ;

		~=""] ; 

	//// result ///////////////

//	~i
List ( 
"=== SG ===";
$sg ;
"==========";
" ";
"~key = " & ~key ;
" ";
"--- JSON RESULT ---" ;
JSON.Format ( ~json )
)


	)










/**
 * 
 * Count total number of nested elements
 *
 * @param {object} json - JSON object
 * @param {text} [startingElementKey] - OPTIONAL: start at the given element, i.e. only return nested count within this element
 *
 * @returnSuccess {number} count of elements
 *
 * @module JSON
 * 
 * @version 1.0.0
 * @author Allen Ulbricht, https://github.com/aulbricht
 *
 */

While ( 

	//// initial variables ////
	[ 

		~json = json ;
		~startingKey = "." ;
		~startingKey = If ( not IsEmpty ( ~startingKey ) ;  ~startingKey ; "." );

		// check for existing and valid original object
		~json = 
			If ( 
				IsEmpty ( ~json ) 
					or Left ( JSONFormatElements ( ~json ) ; 1 ) = "?" ;
				"{}" ;
				~json
				);

		~key_prev = ~startingKey ;
		~key_prev_level = ~startingKey ;

		~key_rootFinal = 
			Let ( ~list = JSONListKeys ( ~json ; ~startingKey );
				GetValue ( ~list ; ValueCount ( ~list ) ) 
				);

		// set the maximum number of iterations as a safety catch against inifite loops
		~maxItems = 1000 ;
		~i = 1 ;
		
		~=""] ; 

	//// "while this is true" loop condition ///////
	~json ≠ "{}" and not IsEmpty ( ~json ) and ~i ≤ 1 ;//~maxItems ; 

	//// logic ////////////////
	[ 


		////////////////////////////////////////////////////////////////
		// get the next deepest key, else get the next root key
		// note: the current key is always the deepest, next child key in the object

		~key = 
			While ( 

				//// initial variables ////
				[ 
		
					~key_deepestElement = "" ;
					~element = "." ; // note: this needs a starting value so the loop doesn't insta-exit
					~maxNestedLevels = 64 ;
					~n = 1 ;
		
					~=""] ; 

				//// "while this is true" loop condition ///////
				not IsEmpty ( ~element ) and ~n ≤ ~maxNestedLevels ; 

				//// logic ////////////////
				[ 

					~element =
						Let ( ~list_nextNestedElements = JSONListKeys ( ~json ; ~key_deepestElement );
							GetValue ( ~list_nextNestedElements ; 1 )
							);
					~key_deepestElement = ~key_deepestElement & If ( not IsEmpty ( ~key_deepestElement ) ; "." ) & ~element ;

					~n = ~n + 1 ;

					~=""] ; 

				//// result ///////////////

				~element //~key_deepestElement


				);

		////////////////////////////////////////////////////////////////



		// get value for the current key
		~json = JSONDeleteElement ( ~json ; ~key );

		// if there are nested elements, manage next behavior appropriately
		~skipThisKey = 
			Let ( ~nestedKeys = JSONGetElement ( ~json ; ~key );

				// if there are no nested keys
				ValueCount ( ~nestedKeys ) = 0

				// if there is only a blank JSON object
				or ~nestedKeys = "{}" 

				);

		// track the number iterations
		~i = ~i + 1 ;

		~=""] ; 

	//// result ///////////////

	~i

	)